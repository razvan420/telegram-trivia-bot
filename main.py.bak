import asyncio
import logging
import json
import os
import random
import math
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, asdict
from pathlib import Path
from collections import defaultdict

from telegram import (
    Update, 
    InlineKeyboardButton, 
    InlineKeyboardMarkup,
    Poll,
    ChatMemberOwner,
    ChatMemberAdministrator
)
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    PollAnswerHandler,
    MessageHandler,
    filters,
    ContextTypes
)
from telegram.constants import ParseMode

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

@dataclass
class QuizQuestion:
    """Data class for quiz questions"""
    question: str
    options: List[str]
    correct_answer: int
    explanation: Optional[str] = None
    difficulty: str = "medium"
    category: str = "general"

@dataclass
class UserScore:
    """Data class for user scores"""
    user_id: int
    username: str
    total_score: int = 0
    questions_answered: int = 0
    correct_answers: int = 0
    last_activity: str = ""
    preferred_language: str = "ro"  # Default to Romanian


class QuestionSelector:
    """Enhanced question selection with multiple strategies"""
    
    def __init__(self, questions: List[QuizQuestion]):
        self.questions = questions
        self.question_weights = defaultdict(float)
        self.user_question_history = defaultdict(set)  # user_id -> set of question indices
        self.global_question_usage = defaultdict(int)  # question_index -> usage_count
        self.category_distribution = self._analyze_categories()
        self.difficulty_distribution = self._analyze_difficulties()
        
        # Initialize weights
        self._initialize_weights()
    
    def _analyze_categories(self) -> Dict[str, List[int]]:
        """Analyze question distribution by category"""
        categories = defaultdict(list)
        for i, question in enumerate(self.questions):
            categories[question.category].append(i)
        return dict(categories)
    
    def _analyze_difficulties(self) -> Dict[str, List[int]]:
        """Analyze question distribution by difficulty"""
        difficulties = defaultdict(list)
        for i, question in enumerate(self.questions):
            difficulties[question.difficulty].append(i)
        return dict(difficulties)
    
    def _initialize_weights(self):
        """Initialize question weights based on rarity and balance"""
        total_questions = len(self.questions)
        
        for i, question in enumerate(self.questions):
            # Base weight
            weight = 1.0
            
            # Category balance weight (favor less common categories)
            category_size = len(self.category_distribution[question.category])
            category_weight = math.log(total_questions / category_size + 1)
            
            # Difficulty balance weight
            difficulty_size = len(self.difficulty_distribution[question.difficulty])
            difficulty_weight = math.log(total_questions / difficulty_size + 1)
            
            # Combine weights
            self.question_weights[i] = weight * category_weight * difficulty_weight
    
    def select_question_weighted_random(self, 
                                      used_questions: Set[int], 
                                      user_id: Optional[int] = None) -> Optional[QuizQuestion]:
        """Select question using weighted random selection"""
        available_indices = [i for i in range(len(self.questions)) if i not in used_questions]
        
        if not available_indices:
            return None
        
        # Filter out questions this user has seen recently (if user_id provided)
        if user_id and user_id in self.user_question_history:
            user_history = self.user_question_history[user_id]
            # Avoid questions seen in last 20 questions
            if len(user_history) > 20:
                recent_questions = set(list(user_history)[-20:])
                available_indices = [i for i in available_indices if i not in recent_questions]
        
        if not available_indices:
            # If no questions available after filtering, use all available
            available_indices = [i for i in range(len(self.questions)) if i not in used_questions]
        
        # Calculate weights for available questions
        weights = []
        for i in available_indices:
            base_weight = self.question_weights[i]
            
            # Reduce weight for frequently used questions globally
            usage_penalty = 1.0 / (1.0 + self.global_question_usage[i] * 0.1)
            
            # Reduce weight for questions user has seen before
            user_penalty = 1.0
            if user_id and i in self.user_question_history.get(user_id, set()):
                user_penalty = 0.3  # Significantly reduce chance of repeat
            
            final_weight = base_weight * usage_penalty * user_penalty
            weights.append(final_weight)
        
        # Select using weighted random choice
        selected_index = random.choices(available_indices, weights=weights)[0]
        
        # Update tracking
        self.global_question_usage[selected_index] += 1
        if user_id:
            self.user_question_history[user_id].add(selected_index)
        
        return self.questions[selected_index]
    
    def select_question_balanced_categories(self, 
                                          used_questions: Set[int],
                                          target_category: Optional[str] = None) -> Optional[QuizQuestion]:
        """Select question ensuring category balance"""
        available_indices = [i for i in range(len(self.questions)) if i not in used_questions]
        
        if not available_indices:
            return None
        
        if target_category and target_category in self.category_distribution:
            # Try to select from target category first
            category_indices = [i for i in self.category_distribution[target_category] 
                              if i in available_indices]
            if category_indices:
                selected_index = random.choice(category_indices)
                self.global_question_usage[selected_index] += 1
                return self.questions[selected_index]
        
        # Group available questions by category
        available_by_category = defaultdict(list)
        for i in available_indices:
            category = self.questions[i].category
            available_by_category[category].append(i)
        
        # Select category with least usage in current session
        category_usage = defaultdict(int)
        for i in used_questions:
            if i < len(self.questions):
                category_usage[self.questions[i].category] += 1
        
        # Find category with minimum usage
        min_usage = min(category_usage.get(cat, 0) for cat in available_by_category.keys())
        candidate_categories = [cat for cat in available_by_category.keys() 
                              if category_usage.get(cat, 0) == min_usage]
        
        selected_category = random.choice(candidate_categories)
        selected_index = random.choice(available_by_category[selected_category])
        
        self.global_question_usage[selected_index] += 1
        return self.questions[selected_index]
    
    def select_question_difficulty_progression(self, 
                                             used_questions: Set[int],
                                             question_number: int,
                                             total_questions: int = 10) -> Optional[QuizQuestion]:
        """Select question with difficulty progression (easy -> medium -> hard)"""
        available_indices = [i for i in range(len(self.questions)) if i not in used_questions]
        
        if not available_indices:
            return None
        
        # Determine target difficulty based on question number
        progress = question_number / total_questions
        
        if progress <= 0.3:  # First 30% - easy questions
            target_difficulty = "easy"
        elif progress <= 0.7:  # Middle 40% - medium questions
            target_difficulty = "medium"
        else:  # Last 30% - hard questions
            target_difficulty = "hard"
        
        # Try to find questions of target difficulty
        target_indices = [i for i in available_indices 
                         if self.questions[i].difficulty == target_difficulty]
        
        if target_indices:
            selected_index = random.choice(target_indices)
        else:
            # Fallback to any available question
            selected_index = random.choice(available_indices)
        
        self.global_question_usage[selected_index] += 1
        return self.questions[selected_index]
    
    def select_question_adaptive(self, 
                               used_questions: Set[int],
                               user_id: int,
                               user_performance: Dict[str, float]) -> Optional[QuizQuestion]:
        """Adaptive selection based on user performance"""
        available_indices = [i for i in range(len(self.questions)) if i not in used_questions]
        
        if not available_indices:
            return None
        
        # Get user's accuracy by difficulty
        easy_accuracy = user_performance.get('easy', 0.5)
        medium_accuracy = user_performance.get('medium', 0.5)
        hard_accuracy = user_performance.get('hard', 0.5)
        
        # Determine target difficulty based on performance
        if easy_accuracy < 0.6:
            target_difficulty = "easy"
        elif medium_accuracy < 0.6:
            target_difficulty = "medium"
        elif hard_accuracy < 0.8:
            target_difficulty = "hard"
        else:
            # User is performing well, mix difficulties
            target_difficulty = random.choice(["medium", "hard"])
        
        # Filter by target difficulty
        target_indices = [i for i in available_indices 
                         if self.questions[i].difficulty == target_difficulty]
        
        if not target_indices:
            target_indices = available_indices
        
        # Apply user history filtering
        if user_id in self.user_question_history:
            user_history = self.user_question_history[user_id]
            if len(user_history) > 15:
                recent_questions = set(list(user_history)[-15:])
                filtered_indices = [i for i in target_indices if i not in recent_questions]
                if filtered_indices:
                    target_indices = filtered_indices
        
        selected_index = random.choice(target_indices)
        
        # Update tracking
        self.global_question_usage[selected_index] += 1
        if user_id:
            self.user_question_history[user_id].add(selected_index)
        
        return self.questions[selected_index]
    
    def get_selection_strategy(self, strategy: str = "weighted_random"):
        """Get selection function based on strategy name"""
        strategies = {
            "weighted_random": self.select_question_weighted_random,
            "balanced_categories": self.select_question_balanced_categories,
            "difficulty_progression": self.select_question_difficulty_progression,
            "adaptive": self.select_question_adaptive,
            "simple_random": self._simple_random_selection
        }
        return strategies.get(strategy, self.select_question_weighted_random)
    
    def _simple_random_selection(self, used_questions: Set[int], **kwargs) -> Optional[QuizQuestion]:
        """Fallback simple random selection"""
        available_indices = [i for i in range(len(self.questions)) if i not in used_questions]
        if not available_indices:
            return None
        
        selected_index = random.choice(available_indices)
        self.global_question_usage[selected_index] += 1
        return self.questions[selected_index]


class QuizBot:
    """Main Telegram Quiz Bot class with enhanced question selection"""
    
    def __init__(self, token: str):
        self.token = token
        self.application = None
        self.questions_ro: List[QuizQuestion] = []  # Only Romanian questions now
        self.user_scores: Dict[int, UserScore] = {}
        self.active_quizzes: Dict[int, Dict] = {}  # chat_id -> quiz_data
        self.scores_file = Path("user_scores.json")
        
        # Enhanced selection components
        self.question_selector_ro: Optional[QuestionSelector] = None
        self.selection_strategy = "weighted_random"  # Default strategy
        self.user_performance_tracking = defaultdict(lambda: defaultdict(list))
        
        # Category files directory
        self.categories_dir = Path("./")
        
        # Translations (Romanian only)
        self.translations = {
            "ro": {
                "welcome": "🎯 **Bun venit la Quiz Bot!** 🎯\n\nApasă /goq pentru a începe un quiz!",
                "goqed": "🎯 Quiz început! Răspunde la întrebări pe măsură ce apar.",
                "quiz_stopped": "⏹️ Quiz oprit!",
                "quiz_ended": "🏁 Quiz terminat!",
                "no_questions": "❌ Nu sunt întrebări disponibile!",
                "quiz_running": "⚠️ Un quiz este deja pornit! Folosește /quiz_stop pentru a-l opri.",
                "admin_only": "❌ Doar adminii pot opri quiz-ul!",
                "no_active_quiz": "❌ Nu există quiz activ de oprit!",
                "no_participation": "📊 Nu ai participat la niciun quiz încă!",
                "no_scores": "📊 Nu sunt scoruri înregistrate încă!",
                "question_number": "🎯 **Întrebarea #{}/10**",
                "quiz_results": "🏆 **Rezultatele Quiz-ului** 🏆",
                "no_participants": "🏁 Quiz terminat! Nimeni nu a participat. 😢",
                "your_stats": "📊 **Statisticile Tale**",
                "leaderboard": "🏆 **Clasamentul Quiz-ului - Top 10** 🏆",
                "player": "👤 **Jucător:**",
                "total_score": "🎯 **Scor Total:**",
                "questions_answered": "❓ **Întrebări Răspunse:**",
                "correct_answers": "✅ **Răspunsuri Corecte:**",
                "accuracy": "📈 **Acuratețe:**",
                "last_activity": "🕐 **Ultima Activitate:**",
                "help_title": "🤖 **Ajutor Quiz Bot** 🤖",
                "help_description": "Bun venit la Quiz Bot! Acest bot îți permite să joci jocuri interactive de quiz în chat-ul tău Telegram.",
                "help_features": "**🎯 Funcționalități:**",
                "help_commands": "**📋 Comenzi Disponibile:**",
                "help_how_to_play": "**🎮 Cum să Joci:**",
                "help_scoring": "**🏆 Sistem de Punctaj:**",
                "categories_loaded": "📚 **Categorii încărcate:**"
            }
        }
        
        # Load existing data
        self.load_data()
        
        # Initialize enhanced question selectors
        self.init_question_selectors()
        
        # Initialize application
        self.init_application()
        
        # Register handlers
        self.register_handlers()
    
    def init_question_selectors(self):
        """Initialize question selectors"""
        self.question_selector_ro = QuestionSelector(self.questions_ro) if self.questions_ro else None
        logger.info(f"Initialized question selector - RO: {bool(self.question_selector_ro)}")
    
    def get_question_selector(self) -> Optional[QuestionSelector]:
        """Get question selector"""
        return self.question_selector_ro
    
    def calculate_user_performance(self, user_id: int) -> Dict[str, float]:
        """Calculate user performance by difficulty"""
        performance = {}
        user_data = self.user_performance_tracking[user_id]
        
        for difficulty in ["easy", "medium", "hard"]:
            if difficulty in user_data and user_data[difficulty]:
                correct_count = sum(user_data[difficulty])
                total_count = len(user_data[difficulty])
                performance[difficulty] = correct_count / total_count
            else:
                performance[difficulty] = 0.5  # Default neutral performance
        
        return performance
    
    def update_user_performance(self, user_id: int, question: QuizQuestion, is_correct: bool):
        """Update user performance tracking"""
        self.user_performance_tracking[user_id][question.difficulty].append(is_correct)
        
        # Keep only last 20 answers per difficulty
        for difficulty in self.user_performance_tracking[user_id]:
            if len(self.user_performance_tracking[user_id][difficulty]) > 20:
                self.user_performance_tracking[user_id][difficulty] = \
                    self.user_performance_tracking[user_id][difficulty][-20:]
    
    def select_next_question_enhanced(self, chat_id: int, user_id: int) -> Optional[QuizQuestion]:
        """Enhanced question selection for QuizBot"""
        if chat_id not in self.active_quizzes:
            return None
        
        quiz_data = self.active_quizzes[chat_id]
        question_count = quiz_data.get('question_count', 1)
        
        selector = self.get_question_selector()
        if not selector:
            return None
        
        # Get used questions (convert to indices)
        used_questions = set()
        for used_q in quiz_data.get('used_questions', []):
            try:
                used_questions.add(self.questions_ro.index(used_q))
            except ValueError:
                continue
        
        # Select based on strategy
        try:
            if self.selection_strategy == "adaptive":
                user_performance = self.calculate_user_performance(user_id)
                return selector.select_question_adaptive(used_questions, user_id, user_performance)
            elif self.selection_strategy == "difficulty_progression":
                return selector.select_question_difficulty_progression(
                    used_questions, question_count, quiz_data.get('max_questions', 10)
                )
            elif self.selection_strategy == "balanced_categories":
                return selector.select_question_balanced_categories(used_questions)
            else:  # weighted_random
                return selector.select_question_weighted_random(used_questions, user_id)
        except Exception as e:
            logger.error(f"Error in enhanced question selection: {e}")
            return None
    
    def init_application(self):
        """Initialize the Telegram application"""
        self.application = Application.builder().token(self.token).build()
    
    def validate_question(self, q_data: dict) -> Optional[QuizQuestion]:
        """Validate question structure"""
        required_fields = ['question', 'options', 'correct_answer']
        if not all(field in q_data for field in required_fields):
            return None
            
        if not isinstance(q_data['options'], list) or len(q_data['options']) < 2:
            return None
            
        try:
            correct_idx = int(q_data['correct_answer'])
            if not 0 <= correct_idx < len(q_data['options']):
                return None
        except (ValueError, TypeError):
            return None
            
        return QuizQuestion(
            question=q_data['question'],
            options=q_data['options'],
            correct_answer=correct_idx,
            explanation=q_data.get('explanation', ''),
            difficulty=q_data.get('difficulty', 'medium'),
            category=q_data.get('category', 'general')
        )
    
    def load_questions_from_categories(self) -> List[QuizQuestion]:
        """Load questions from all category files in categories/ directory"""
        all_questions = []
        categories_loaded = []
        
        if not self.categories_dir.exists():
            logger.warning(f"Categories directory not found: {self.categories_dir}")
            return all_questions
        
        # Expected category files
        category_files = [
            'ro-questions.json'
        ]
        
        for category_file in category_files:
            file_path = self.categories_dir / category_file
            try:
                if not file_path.exists():
                    logger.warning(f"Category file not found: {file_path}")
                    continue
                    
                with open(file_path, 'r', encoding='utf-8') as f:
                    try:
                        questions_data = json.load(f)
                    except json.JSONDecodeError:
                        logger.error(f"Invalid JSON in file: {file_path}")
                        continue
                        
                    questions_list = []
                    if isinstance(questions_data, list):
                        questions_list = questions_data
                    elif isinstance(questions_data, dict) and 'questions' in questions_data:
                        questions_list = questions_data['questions']
                    
                    category_count = 0
                    for i, q_data in enumerate(questions_list):
                        try:
                            question = self.validate_question(q_data)
                            if question:
                                all_questions.append(question)
                                category_count += 1
                        except Exception as e:
                            logger.error(f"Error parsing question {i+1} from {category_file}: {e}")
                            continue
                    
                    if category_count > 0:
                        category_name = category_file.replace('.json', '').replace('-', ' ').title()
                        categories_loaded.append(f"{category_name}: {category_count}")
                        logger.info(f"Loaded {category_count} questions from {category_file}")
                    
            except Exception as e:
                logger.error(f"Error loading questions from {file_path}: {e}")
        
        logger.info(f"Total questions loaded: {len(all_questions)} from {len(categories_loaded)} categories")
        if categories_loaded:
            logger.info(f"Categories: {', '.join(categories_loaded)}")
        
        return all_questions
    
    def load_data(self):
        """Load questions and scores from files"""
        # Load Romanian questions from category files
        self.questions_ro = self.load_questions_from_categories()
        
        # Load user scores
        try:
            if self.scores_file.exists():
                with open(self.scores_file, 'r', encoding='utf-8') as f:
                    scores_data = json.load(f)
                    self.user_scores = {
                        int(uid): UserScore(**data) 
                        for uid, data in scores_data.items()
                    }
                    logger.info(f"Loaded scores for {len(self.user_scores)} users")
        except Exception as e:
            logger.error(f"Error loading scores: {e}")
    
    def save_data(self):
        """Atomic save with backup"""
        try:
            scores_data = {str(uid): asdict(score) for uid, score in self.user_scores.items()}
            
            # Write to temp file first
            temp_path = self.scores_file.with_suffix('.tmp')
            with open(temp_path, 'w', encoding='utf-8') as f:
                json.dump(scores_data, f, indent=2, ensure_ascii=False)
                
            # Create backup
            if self.scores_file.exists():
                backup_path = self.scores_file.with_suffix('.bak')
                if backup_path.exists():
                    backup_path.unlink()
                self.scores_file.rename(backup_path)
                
            # Move temp to main
            temp_path.rename(self.scores_file)
            
        except Exception as e:
            logger.error(f"Critical save error: {e}")
            # Attempt to restore from backup if available
            if 'backup_path' in locals() and backup_path.exists():
                try:
                    backup_path.rename(self.scores_file)
                except Exception as restore_error:
                    logger.critical(f"Failed to restore backup: {restore_error}")
    
    def get_text(self, key: str) -> str:
        """Get Romanian text for key"""
        return self.translations["ro"].get(key, key)
    
    def register_handlers(self):
        """Register all command and callback handlers"""
        # Command handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("goq", self.start_quiz_command))
        self.application.add_handler(CommandHandler("quiz_stop", self.stop_quiz_command))
        self.application.add_handler(CommandHandler("personal_score", self.show_scores_command))
        self.application.add_handler(CommandHandler("global_socre", self.leaderboard_command))
        self.application.add_handler(CommandHandler("quiz_help", self.help_command))
        self.application.add_handler(CommandHandler("quiz_strategy", self.strategy_command))
        
        # Poll answer handler
        self.application.add_handler(PollAnswerHandler(self.handle_poll_answer))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        await update.message.reply_text(
            self.get_text("welcome"),
            parse_mode=ParseMode.MARKDOWN
        )
    
    async def strategy_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /quiz_strategy command to change selection strategy"""
        user_id = update.effective_user.id
        
        # Check if user is admin (you might want to restrict this)
        try:
            member = await context.bot.get_chat_member(update.effective_chat.id, user_id)
            if not isinstance(member, (ChatMemberOwner, ChatMemberAdministrator)):
                await update.message.reply_text("❌ Doar adminii pot schimba strategia quiz-ului!")
                return
        except:
            pass
        
        if context.args:
            strategy = context.args[0].lower()
            valid_strategies = ["weighted_random", "balanced_categories", "difficulty_progression", "adaptive", "simple_random"]
            
            if strategy in valid_strategies:
                self.selection_strategy = strategy
                await update.message.reply_text(f"✅ Strategia quiz-ului schimbată la: **{strategy}**", parse_mode=ParseMode.MARKDOWN)
            else:
                await update.message.reply_text(f"❌ Strategie invalidă. Opțiuni valide: {', '.join(valid_strategies)}")
        else:
            await update.message.reply_text(
                f"🎯 **Strategia Curentă:** {self.selection_strategy}\n\n"
                f"**Strategii Disponibile:**\n"
                f"• `weighted_random` - Selecție inteligentă cu istoricul utilizatorului\n"
                f"• `balanced_categories` - Distribuție echilibrată a categoriilor\n"
                f"• `difficulty_progression` - Ușor → Mediu → Greu\n"
                f"• `adaptive` - Se adaptează la performanța utilizatorului\n"
                f"• `simple_random` - Selecție aleatoare de bază\n\n"
                f"**Utilizare:** `/quiz_strategy [nume_strategie]`",
                parse_mode=ParseMode.MARKDOWN
            )
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /quiz_help command"""
        # Get category statistics
        category_stats = defaultdict(int)
        difficulty_stats = defaultdict(int)
        
        for question in self.questions_ro:
            category_stats[question.category] += 1
            difficulty_stats[question.difficulty] += 1
        
        categories_text = "\n".join([f"• {cat.replace('-', ' ').title()}: {count} întrebări" 
                                   for cat, count in category_stats.items()])
        
        difficulty_text = "\n".join([f"• {diff.title()}: {count} întrebări" 
                                   for diff, count in difficulty_stats.items()])
        
        help_text = f"""
{self.get_text('help_title')}

{self.get_text('help_description')}

{self.get_text('help_features')}
• 🎮 Quiz-uri interactive cu întrebări cu alegere multiplă
• 🏆 Sistem de punctaj și clasament
• 📊 Statistici personale detaliate
• ⏱️ Întrebări cu timp limitat (15 secunde)
• 🎯 10 întrebări per sesiune de quiz
• 🧠 Selecție inteligentă de întrebări
• 🎲 Multiple strategii de selecție

{self.get_text('help_commands')}
• `/start` - Mesaj de bun venit
• `/goq` - Începe un nou quiz
• `/quiz_stop` - Oprește quiz-ul curent (doar pentru admini)
• `/personal_score` - Vezi statisticile tale personale
• `/global_socre` - Vezi clasamentul jucătorilor
• `/quiz_help` - Afișează acest mesaj de ajutor
• `/quiz_strategy` - Schimbă strategia de selecție (admini)

{self.get_text('help_how_to_play')}
1. Folosește `/goq` pentru a începe un quiz
2. Răspunde la întrebări făcând clic pe opțiunea corectă
3. Ai 15 secunde pentru fiecare întrebare
4. Quiz-ul se termină după 10 întrebări
5. Vezi rezultatele și clasamentul la final

{self.get_text('categories_loaded')}
{categories_text}

**📊 Distribuția pe Dificultate:**
{difficulty_text}

{self.get_text('help_scoring')}
• +1 punct pentru fiecare răspuns correct
• Statistici detaliate includ acuratețea și activitatea
• Clasamentul se bazează pe scorul total
• Progresul se salvează automat
• Selecția inteligentă se adaptează la performanța ta

**📈 Total Întrebări:** {len(self.questions_ro)}
        """
        
        await update.message.reply_text(help_text.strip(), parse_mode=ParseMode.MARKDOWN)
    
    async def start_quiz_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /goq command"""
        chat_id = update.effective_chat.id
        user_id = update.effective_user.id
        
        # Initialize user if not exists
        if user_id not in self.user_scores:
            self.user_scores[user_id] = UserScore(
                user_id=user_id,
                username=update.effective_user.username or update.effective_user.first_name or f"User_{user_id}",
                preferred_language="ro"
            )
        
        if not self.questions_ro:
            await update.message.reply_text(self.get_text("no_questions"))
            return
        
        # Check if quiz is already running
        if chat_id in self.active_quizzes:
            await update.message.reply_text(self.get_text("quiz_running"))
            return
        
        # Ensure clean state - remove any leftover quiz data
        if chat_id in self.active_quizzes:
            del self.active_quizzes[chat_id]
        
        # Try enhanced selection first, fallback to random
        quiz_question = self.select_next_question_enhanced(chat_id, user_id)
        if not quiz_question:
            quiz_question = random.choice(self.questions_ro)
        
        self.active_quizzes[chat_id] = {
            'current_question': quiz_question,
            'question_count': 1,
            'max_questions': 10,
            'participants': {},
            'start_time': datetime.now(),
            'available_questions': self.questions_ro.copy(),
            'used_questions': [quiz_question],
            'poll_id': None,
            'poll_message_id': None,
            'initiator_user_id': user_id
        }
        
        await update.message.reply_text(self.get_text("goqed"))
        
        # Add a small delay to ensure message is sent before poll
        await asyncio.sleep(0.5)
        await self.send_quiz_question(chat_id, quiz_question)
    
    async def send_quiz_question(self, chat_id: int, question: QuizQuestion):
        """Send a quiz question as a poll"""
        try:
            if chat_id not in self.active_quizzes:
                logger.warning(f"Attempted to send question to inactive quiz in chat {chat_id}")
                return
                
            quiz_data = self.active_quizzes[chat_id]
            
            question_text = f"{self.get_text('question_number').format(quiz_data['question_count'])}\n\n{question.question}"
            
            # Send poll
            poll_message = await self.application.bot.send_poll(
                chat_id=chat_id,
                question=question_text,
                options=question.options,
                type=Poll.QUIZ,
                correct_option_id=question.correct_answer,
                explanation=question.explanation or f"Răspunsul corect este: {question.options[question.correct_answer]}",
                is_anonymous=False,
                open_period=15  # 15 seconds to answer
            )
            
            # Update quiz data with poll info
            quiz_data['poll_id'] = poll_message.poll.id
            quiz_data['poll_message_id'] = poll_message.message_id
            
            logger.info(f"Sent question {quiz_data['question_count']} to chat {chat_id}")
            
            # Schedule next question
            asyncio.create_task(self.schedule_next_question(chat_id, 20))
            
        except Exception as e:
            logger.error(f"Error sending quiz question to chat {chat_id}: {e}")
            await self.end_quiz(chat_id)
    
    async def schedule_next_question(self, chat_id: int, delay: int):
        """Schedule the next question after a delay"""
        try:
            await asyncio.sleep(delay)
            
            # Check if quiz is still active
            if chat_id not in self.active_quizzes:
                logger.info(f"Quiz in chat {chat_id} was stopped, cancelling next question")
                return
                
            quiz_data = self.active_quizzes[chat_id]
            quiz_data['question_count'] += 1
            
            if quiz_data['question_count'] > quiz_data['max_questions']:
                logger.info(f"Quiz in chat {chat_id} reached max questions, ending")
                await self.end_quiz(chat_id)
                return
                
            initiator_user_id = quiz_data.get('initiator_user_id', 0)
            
            # Try enhanced selection first
            next_question = self.select_next_question_enhanced(chat_id, initiator_user_id)
            
            # Fallback to original logic if enhanced selection fails
            if not next_question:
                available_questions = quiz_data.get('available_questions', [])
                used_questions = quiz_data.get('used_questions', [])
                remaining_questions = [q for q in available_questions if q not in used_questions]
                
                # If no remaining questions, reset used questions
                if not remaining_questions:
                    remaining_questions = available_questions
                    quiz_data['used_questions'] = []
                    logger.info(f"Reset used questions for chat {chat_id}")
                
                if remaining_questions:
                    next_question = random.choice(remaining_questions)
                else:
                    logger.error(f"No questions available for chat {chat_id}")
                    await self.end_quiz(chat_id)
                    return
            
            quiz_data['current_question'] = next_question
            quiz_data['used_questions'].append(next_question)
            
            logger.info(f"Scheduling question {quiz_data['question_count']} for chat {chat_id}")
            await self.send_quiz_question(chat_id, next_question)
            
        except Exception as e:
            logger.error(f"Error in question scheduling for chat {chat_id}: {e}")
            if chat_id in self.active_quizzes:
                await self.end_quiz(chat_id)
    
    async def handle_poll_answer(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle poll answers with robust scoring and performance tracking"""
        try:
            poll_answer = update.poll_answer
            user = poll_answer.user
            chat_id = None
            
            # Find which chat this poll belongs to
            for cid, quiz_data in self.active_quizzes.items():
                if quiz_data.get('poll_id') == poll_answer.poll_id:
                    chat_id = cid
                    break
            
            if not chat_id:
                return
                
            quiz_data = self.active_quizzes[chat_id]
            current_question = quiz_data['current_question']
            
            # Initialize user if not exists
            if user.id not in self.user_scores:
                self.user_scores[user.id] = UserScore(
                    user_id=user.id,
                    username=user.username or user.first_name or f"User_{user.id}",
                    preferred_language="ro",
                    last_activity=datetime.now().isoformat()
                )
            
            user_score = self.user_scores[user.id]
            user_score.questions_answered += 1
            user_score.last_activity = datetime.now().isoformat()
            
            # Check if answer is correct
            selected_options = poll_answer.option_ids
            is_correct = selected_options and selected_options[0] == current_question.correct_answer
            
            if is_correct:
                user_score.correct_answers += 1
                user_score.total_score += 1
                quiz_data['participants'][user.id] = quiz_data['participants'].get(user.id, 0) + 1
            else:
                if user.id not in quiz_data['participants']:
                    quiz_data['participants'][user.id] = 0
            
            # Update performance tracking for enhanced selection
            self.update_user_performance(user.id, current_question, is_correct)
            
            self.save_data()
        except Exception as e:
            logger.error(f"Error handling poll answer: {e}")
    
    async def end_quiz(self, chat_id: int):
        """End the quiz and show results with error handling"""
        try:
            if chat_id not in self.active_quizzes:
                return
                
            quiz_data = self.active_quizzes[chat_id]
            participants = quiz_data['participants']
            
            # Clear the current poll if it exists
            if 'poll_message_id' in quiz_data and quiz_data['poll_message_id']:
                try:
                    await self.application.bot.stop_poll(
                        chat_id=chat_id,
                        message_id=quiz_data['poll_message_id']
                    )
                except Exception as e:
                    logger.error(f"Error stopping poll: {e}")
            
            # Clean up quiz data immediately
            del self.active_quizzes[chat_id]
            
            if not participants:
                await self.application.bot.send_message(
                    chat_id=chat_id,
                    text=self.get_text("no_participants")
                )
            else:
                sorted_participants = sorted(
                    participants.items(), 
                    key=lambda x: x[1], 
                    reverse=True
                )
                
                results_text = f"{self.get_text('quiz_results')}\n\n"
                medals = ["🥇", "🥈", "🥉"]
                
                for i, (user_id, score) in enumerate(sorted_participants[:5]):
                    user_data = self.user_scores.get(user_id)
                    username = user_data.username if user_data else "Necunoscut"
                    medal = medals[i] if i < 3 else f"{i+1}."
                    results_text += f"{medal} {username}: {score} puncte\n"
                
                await self.application.bot.send_message(
                    chat_id=chat_id,
                    text=results_text,
                    parse_mode=ParseMode.MARKDOWN
                )
            
        except Exception as e:
            logger.error(f"Error ending quiz: {e}")
            # Ensure cleanup even if there's an error
            if chat_id in self.active_quizzes:
                del self.active_quizzes[chat_id]
    
    async def stop_quiz_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /quiz_stop command with proper admin validation"""
        chat_id = update.effective_chat.id
        user_id = update.effective_user.id
        
        try:
            member = await context.bot.get_chat_member(chat_id, user_id)
            if not (isinstance(member, (ChatMemberOwner, ChatMemberAdministrator)) or member.status == 'administrator'):
                await update.message.reply_text(self.get_text("admin_only"))
                return
        except Exception as e:
            logger.error(f"Error checking admin status: {e}")
            await update.message.reply_text("Eroare la verificarea permisiunilor")
            return
            
        if chat_id not in self.active_quizzes:
            await update.message.reply_text(self.get_text("no_active_quiz"))
            return
        
        await self.end_quiz(chat_id)
        await update.message.reply_text(self.get_text("quiz_stopped"))
    
    async def show_scores_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /personal_score command with proper formatting"""
        user_id = update.effective_user.id
        
        if user_id not in self.user_scores:
            await update.message.reply_text(self.get_text("no_participation"))
            return
        
        user_score = self.user_scores[user_id]
        accuracy = (user_score.correct_answers / user_score.questions_answered * 100) if user_score.questions_answered > 0 else 0
        
        # Get performance by difficulty
        performance = self.calculate_user_performance(user_id)
        performance_text = "\n".join([
            f"  • {diff.title()}: {perf*100:.1f}%" 
            for diff, perf in performance.items() 
            if perf > 0
        ])
        
        # Get performance by category
        category_performance = defaultdict(lambda: {'correct': 0, 'total': 0})
        for question in self.questions_ro:
            if hasattr(self, 'user_performance_tracking') and user_id in self.user_performance_tracking:
                # This is a simplified approach - in practice you'd need more detailed tracking
                pass
        
        stats_text = f"""
{self.get_text('your_stats')}

{self.get_text('player')} {user_score.username}
{self.get_text('total_score')} {user_score.total_score}
{self.get_text('questions_answered')} {user_score.questions_answered}
{self.get_text('correct_answers')} {user_score.correct_answers}
{self.get_text('accuracy')} {accuracy:.1f}%
{self.get_text('last_activity')} {user_score.last_activity.split('T')[0] if user_score.last_activity else 'Niciodată'}

**📈 Performanță pe Dificultate:**
{performance_text or '  Nu există date încă'}
        """
        
        await update.message.reply_text(stats_text.strip(), parse_mode=ParseMode.MARKDOWN)
    
    async def leaderboard_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /global_socre command with proper formatting"""
        user_id = update.effective_user.id
        
        if not self.user_scores:
            await update.message.reply_text(self.get_text("no_scores"))
            return
        
        sorted_users = sorted(
            self.user_scores.values(),
            key=lambda x: x.total_score,
            reverse=True
        )
        
        leaderboard_text = f"{self.get_text('leaderboard')}\n\n"
        medals = ["🥇", "🥈", "🥉"]
        
        for i, user_score in enumerate(sorted_users[:10]):
            medal = medals[i] if i < 3 else f"{i+1}."
            accuracy = (user_score.correct_answers / user_score.questions_answered * 100) if user_score.questions_answered > 0 else 0
            leaderboard_text += f"{medal} **{user_score.username}** - {user_score.total_score} pct ({accuracy:.1f}%)\n"
        
        await update.message.reply_text(leaderboard_text.strip(), parse_mode=ParseMode.MARKDOWN)
    
    async def _shutdown(self):
        """Proper cleanup on shutdown"""
        try:
            if hasattr(self, 'application'):
                if hasattr(self.application, 'updater'):
                    await self.application.updater.stop()
                await self.application.stop()
                await self.application.shutdown()
            self.save_data()
        except Exception as e:
            logger.error(f"Error during shutdown: {e}")
    
    async def run(self):
        """Main bot run loop with proper error handling"""
        logger.info("Starting Enhanced Quiz Bot with category-based questions...")
        
        try:
            await self.application.initialize()
            await self.application.start()
            
            if not hasattr(self.application, 'updater'):
                raise RuntimeError("Application updater not initialized")
                
            await self.application.updater.start_polling(
                allowed_updates=Update.ALL_TYPES,
                drop_pending_updates=True,
                timeout=10
            )
            
            logger.info("Enhanced Quiz Bot is running!")
            print("🚀 Enhanced Quiz Bot is running!")
            print(f"🧠 Question Selection Strategy: {self.selection_strategy}")
            print(f"📚 Loaded Questions: {len(self.questions_ro)} (Romanian)")
            
            # Show category breakdown
            if self.questions_ro:
                category_stats = defaultdict(int)
                difficulty_stats = defaultdict(int)
                for q in self.questions_ro:
                    category_stats[q.category] += 1
                    difficulty_stats[q.difficulty] += 1
                
                print("📊 Categories:")
                for cat, count in category_stats.items():
                    print(f"   • {cat.replace('-', ' ').title()}: {count}")
                
                print("🎯 Difficulties:")
                for diff, count in difficulty_stats.items():
                    print(f"   • {diff.title()}: {count}")
            
            print("🔄 Commands: /start, /goq, /quiz_stop, /personal_score, /global_socre, /quiz_help, /quiz_strategy")
            print("Press Ctrl+C to stop the bot")
            
            while True:
                await asyncio.sleep(1)
                
        except asyncio.CancelledError:
            logger.info("Bot shutdown requested")
        except Exception as e:
            logger.critical(f"Fatal error: {e}")
        finally:
            await self._shutdown()


# Configuration
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

async def main():
    """Main function to run the bot with proper initialization"""
    if not BOT_TOKEN or BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
        print("❌ Please set TELEGRAM_BOT_TOKEN environment variable with your actual bot token!")
        print("💡 You can get a bot token from @BotFather on Telegram")
        return
    
    try:
        bot = QuizBot(BOT_TOKEN)
        
        if not bot.questions_ro:
            print("❌ No questions loaded! Please create category files in categories/ directory.")
            print("💡 Expected files:")
            print("   • categories/stiinte-natura.json")
            print("   • categories/istorie.json") 
            print("   • categories/geografie.json")
            print("\n💡 Each file should contain an array of questions in this format:")
            print("""
            [
                {
                    "question": "Care este capitala României?",
                    "options": ["Sofia", "Budapesta", "București", "Belgrad"],
                    "correct_answer": 2,
                    "explanation": "București este capitala și cel mai mare oraș al României.",
                    "difficulty": "easy",
                    "category": "geografie"
                }
            ]
            """)
            return
        
        await bot.run()
        
    except KeyboardInterrupt:
        print("\n👋 Bot stopped by user")
    except Exception as e:
        logger.error(f"Error running bot: {e}")
        print(f"❌ Unexpected error: {e}")

if __name__ == "__main__":
    asyncio.run(main())